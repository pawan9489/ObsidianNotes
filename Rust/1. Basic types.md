
|                        | Types                                      | Literals                       |
| ---------------------- | ------------------------------------------ | ------------------------------ |
| Signed integers        | `i8`,¬†`i16`,¬†`i32`,¬†`i64`,¬†`i128`,¬†`isize` | `-10`,¬†`0`,¬†`1_000`,¬†`123_i64` |
| Unsigned integers      | `u8`,¬†`u16`,¬†`u32`,¬†`u64`,¬†`u128`,¬†`usize` | `0`,¬†`123`,¬†`10_u16`           |
| Floating point numbers | `f32`,¬†`f64`                               | `3.14`,¬†`-10.0e20`,¬†`2_f32`    |
| Unicode scalar values  | `char` (32 bits)                           | `'a'`,¬†`'Œ±'`,¬†`'‚àû'`            |
| Booleans               | `bool` (8 bits)                            | `true`,¬†`false`                |
Strings in Rust are `Vec<u8>` but not `Vec<char>` for memory efficiency.
## Unicode and Encodings
* **Unicode** is a universal standard that assigns a unique number, called a **code point**, to every character, symbol, and emoji. The standard defines over 1.4 million possible code points, which requires up to 21 bits of information. A **32-bit (4-byte)** number is the smallest, standard, CPU-friendly size that can hold any possible code point, which is why it's used as the in-memory representation for a single logical character in many systems, including Rust's `char`.
* An **encoding** (like UTF-8, UTF-16, or UTF-32) is the set of rules for how to store these code points in a sequence of bytes.
* ##### UTF-8 Encoding
	* UTF-8 is a **variable-width encoding** that uses **8-bit (1-byte)** units. It's the dominant encoding on the web and in most modern systems.
	- **Byte Usage:**
	    - **1 Byte:** All standard ASCII characters.
	    - **2 Bytes:** Common accented Latin characters (e.g., `√©`, `√∂`).
	    - **3 Bytes:** Most common characters from East Asian languages (e.g., Chinese, Japanese, Korean).
	    - **4 Bytes:** Rarer characters, symbols, and all modern emojis (e.g., `üòÇ`, `ü¶Ä`).
	- **Decoding:** The first byte of a sequence tells you how many bytes are in the character's encoding.
	    - `0xxxxxxx`: 1-byte character (ASCII).
	    - `110xxxxx`: Start of a 2-byte character.
	    - `1110xxxx`: Start of a 3-byte character.
	    - `11110xxx`: Start of a 4-byte character.
	    - `10xxxxxx`: A "continuation byte," not the start of a character.
	- **Validation:** A sequence of bytes is only valid UTF-8 if each start byte is followed by the correct number of continuation bytes. This is why not every `Vec<u8>` is a valid `String`. Functions like `String::from_utf8_lossy()` handle invalid sequences by replacing errors with the ÔøΩ symbol.
	- **Pros & Cons:**
	    - ‚úÖ **Pro:** Extremely compact for ASCII-heavy text. No byte-order issues.
	    - ‚ùå **Con:** Some characters, particularly from East Asian scripts, can take more space than in UTF-16 (3 bytes vs. 2).
	    - ‚ùå **Con:** You can't index into a string to get the Nth character in constant time; you must scan from the beginning.
* UTF-16
* UTF-16 is a **variable-width encoding** that uses **16-bit (2-byte)** units. It's used by systems like Windows and Java internally.
- **Surrogate Pairs:**
    - UTF-16 represents the most common characters (from the "Basic Multilingual Plane" or BMP that means mostly all languages) with a **single 2-byte unit**.
    - To represent characters outside the BMP (like emojis), UTF-16 uses a **surrogate pair**: a "high surrogate" followed by a "low surrogate." These two 2-byte units combine to form a **4-byte** representation of a single logical character.
- **Pros & Cons:**
    - ‚úÖ **Pro:** More compact than UTF-8 for text that is heavy with East Asian characters.
    - ‚ùå **Con:** Wastes space for ASCII text, using 2 bytes where UTF-8 uses 1.
    - ‚ùå **Con:** The complexity of surrogate pairs makes processing more difficult than UTF-8's simpler continuation byte model.
    - ‚ùå **Con:** Still doesn't allow for constant-time indexing for all characters.
* A Rust `char` is a **32-bit Unicode Scalar Value**. Think of it as a single, **decoded, logical character**. It's the _result_ of interpreting a UTF-8 byte sequence.
- A Rust `String` is the `Vec<u8>` that stores the text using the **UTF-8 encoding rules**.

So, a `String` stores the encoded bytes (1-4 bytes per character), while a `char` is the 4-byte type that can hold any single character after it has been decoded from that byte stream.

```rust
fn main() {
    let emoji_str = "ü¶Ä"; // [240, 159, 166, 128]
    // [11110000, 10011111, 10100110, 10000000]
    let emoji_char = 'ü¶Ä' as u32; // 129408
    // 00000000-00000001-11111001-10000000
}
```

## Simple types aka `Copy aka memcpy` safe:
* All above primitives
* **All immutable references:** `&T` for any `T`. A reference is just a memory address, which is cheap to copy. _Crucially, this only copies the reference (the pointer), not the data it points to._
- **All raw pointers:** `*const T` and `*mut T`.
- **All function pointers:** e.g., `fn(i32) -> i32`.
- **NOTE**: `&mut T` is not a copy, if it is copy then multiple references can mutate the data. So they are moved.
##### The Most Important Rule: `Copy` is Composable

This is the key takeaway. Compound types can also be `Copy`, but only if they are made up _entirely_ of other `Copy` types.
- **Tuples:** A tuple is `Copy` if and only if **all** of its elements are `Copy`.
    - `(i32, bool)` is `Copy`.
    - `(f64, &str)` is `Copy`.
    - `(i32, String)` is **NOT** `Copy` because `String` is not `Copy`.
- **Arrays:** An array is `Copy` if and only if **all** of its elements are `Copy`.
    - `[i32; 10]` is `Copy`.
    - `[(u8, u8); 3]` is `Copy`.
    - `[String; 10]` is **NOT** `Copy`.
- **Structs and Enums:** You can make your own types `Copy` by using `#[derive(Copy)]`, but the compiler will only allow this if **all** the fields in your `struct` or `enum` are also `Copy`.
##### What is famously NOT `Copy`?

Any type that manages memory on the heap is not `Copy`, because just copying the bits would result in two variables thinking they own the same memory, leading to a double-free error when they both go out of scope.
- `String`
- `Vec<T>`
- `HashMap<K, V>`
- `Box<T>`

So, the simplest way to remember it is: **If it owns heap data, it's not `Copy`.**

## What is a DST?

A **Dynamically Sized Type (DST)** is a type whose exact size is not known at compile time. In Rust, there are three you'll encounter:

1. `str` (a string slice)
2. `[T]` (a generic slice)
3. `dyn Trait` (a trait object)

**The Golden Rule:** You cannot store a DST directly in a variable, pass it as a function argument, or return it by value. DSTs **must always** be used behind some form of pointer.

---

### üëë Single Ownership (Exclusive Owners)

**Concept:** One variable is the exclusive owner. When the owner is dropped, the data is freed.
#### For `Sized` Types (like `i32`, `MyStruct`)

- **`Box<T>`:** A simple thin pointer on the stack that owns a fixed-size block of data on the heap.

    ```
    STACK                      HEAP
    my_box: [ ptr ] ---------> [ MyStruct's data ]
    ```

- **`String` & `Vec<T>`:** These are special `struct`s on the stack that control a growable buffer on the heap.

    ```
    STACK                                  HEAP
    my_string: [ ptr | len | capacity ] ---> [ byte data... ]
    ```

#### For Dynamically Sized Types (DSTs like `str`, `[T]`, `dyn Trait`)

- **`Box<DST>`:** To own a DST, `Box` becomes a **fat pointer on the stack**. It holds the address and the necessary metadata (length or vtable pointer). The heap contains only the raw data.

    ```
    STACK                                     HEAP
    boxed_str:   [ address | length ] ------> [ string byte data... ]
    boxed_trait: [ address | vtable_ptr ] --> [ concrete struct's data... ]
    ```    

---

### ü§ù Shared Ownership (Multiple Owners)

**Concept:** Multiple variables share ownership via a reference count. Data is freed when the last owner is dropped. These are always **thin pointers** on the stack because they store all metadata on the heap.
#### For `Sized` Types (like `i32`, `MyStruct`)

- **`Rc<T>` & `Arc<T>`:** A thin pointer on the stack points to a heap block containing both the reference counts and the data.

    ```
    STACK                                  HEAP
    owner_1: [ ptr ] --+
                       |
                       +-----------------> [ ref_counts | MyStruct's data ]
                       |
    owner_2: [ ptr ] --+
    ```

#### For Dynamically Sized Types (DSTs like `str`, `[T]`, `dyn Trait`)

- **`Rc<DST>` & `Arc<DST>`:** The thin pointer on the stack points to a single heap block that contains everything: reference counts, DST metadata (length/vtable), and the actual data.

    ```
    STACK                                  HEAP
    owner_1: [ ptr ] --+
                       |
                       +--> [ ref_counts | length | string byte data... ]
                       |
    owner_2: [ ptr ] --+
    
    
    // --- For a Trait Object ---
    STACK                                  HEAP
    owner_1: [ ptr ] --+
                       |
                       +--> [ ref_counts | vtable_ptr | struct's data... ]
                       |
    owner_2: [ ptr ] --+
    ```

---

### üó∫Ô∏è Borrowed Access (Temporary Views)

**Concept:** A non-owning pointer (`&`) that provides temporary access to data owned by someone else.

#### For `Sized` Types (like `i32`, `MyStruct`)

- **`&T` (Thin Reference):** A simple, thin pointer on the stack that holds the memory address of the borrowed data.

    ```
    ANY MEMORY (Stack/Heap/Static)         STACK
    owner:  [ data T ]        <----------- borrow: [ address ]
    ```
#### For Dynamically Sized Types (DSTs like `str`, `[T]`, `dyn Trait`)

- **`&DST` (Fat Reference):** A fat pointer on the stack that must carry both the address and the necessary metadata, as it cannot control the layout of the memory it points to.

    ```
    ANY MEMORY                             STACK
    owner: [ data... ]        <----------- str_borrow:    [ address | length ]
                                           slice_borrow:  [ address | length ]
                                           trait_borrow:  [ address | vtable_ptr ]
    ```


## Static lifetime
The¬†'static¬†lifetime is a reserved lifetime name. It means "this reference is valid for the entire duration of the program." It is the longest possible lifetime.

There are two main ways a reference can get a¬†'static¬†lifetime:
1. **From a string literal:**¬†String literals (e.g.,¬†"hello") are baked directly into the program's binary executable file. They are loaded into memory when the program starts and are never deallocated. Therefore, a reference to a string literal is always valid.
2. **From data you explicitly leak:**¬†By using functions like¬†`Box::leak`, you can intentionally tell Rust to "forget" about cleaning up some heap-allocated data, effectively making it live forever and giving you a¬†&'static¬†reference to it. This is an advanced and rare use case.

|                                     | static¬†variable (&'static str)                                              | Box::leak()-ed memory (&'static String)                                                                                                          |
| ----------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Where is the data?**              | Baked into the executable file.                                             | Allocated on the heap¬†at runtime.                                                                                                                |
| **Is¬†Drop¬†called?**                 | N/A. The data is never "owned" in a way that requires dropping. It just¬†is. | **No.**¬†This is the point of¬†leak.                                                                                                               |
| **Is it a memory leak in Rust?**    | No.                                                                         | **Yes.**¬†Rust's ownership system no longer manages it.                                                                                           |
| **Is it a memory leak for the OS?** | No.                                                                         | **No.**¬†The OS reclaims it when the process exits.                                                                                               |
| **When to worry?**                  | Never. This is perfectly normal.                                            | In a long-running program (like a server). If you call¬†leak¬†in a loop, your program's memory usage will grow indefinitely until the OS kills it. |
