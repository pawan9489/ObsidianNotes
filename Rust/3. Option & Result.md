**1. `Option<T>`: The "Maybe" Type**
- **Core Idea:** Represents a value that could be present or absent. It forces you to handle the "nothing" case at compile time.
- **Definition:**
    ```rust
    enum Option<T> {
        Some(T), // A value of type T is present
        None,    // No value is present
    }
    ```
- **Key Takeaway:** Eliminates null pointer errors. If a function returns `Option<String>`, you must check if it's Some before you can use the String.
- **Handling Option:**
    - **match (Exhaustive):** The most robust way. Guarantees all cases are handled.
        ```rust
        match my_option {
            Some(value) => println!("Got {}", value),
            None => println!("Got nothing."),
        }
        ```
    - **if let (Concise):** Best when you only care about the Some case and have a simple else for None.
        ```rust
        if let Some(value) = my_option {
            println!("Got {}", value);
        }
        ```
    - **Combinators (Functional Style):** Methods like `.map()`, `.and_then()`, `.unwrap_or()`, `.ok_or()` allow for chaining transformations without match blocks.

**2. `Result<T, E>`: The "Fallible" Type**
- **Core Idea:** Represents the outcome of an operation that can either succeed or fail.
- **Definition:**
   ```rust
    enum Result<T, E> {
        Ok(T),  // Operation succeeded with a value of type T
        Err(E), // Operation failed with an error of type E
    }
    ```
- **Key Takeaway:** Makes error handling explicit and robust. Functions that can fail must declare it in their signature, and callers must handle the Err case.
- **Handling Result:**
    - **match and if let:** Work just like with Option.
    - **The ? Operator (The "Happy Path"):** The most idiomatic way to handle Result inside a function that also returns a Result.
        - If the result is Ok(value), it unwraps it to value.
        - If the result is Err(error), it immediately returns that Err from the current function.
        ```rust
        fn do_many_things() -> Result<(), MyError> {
            let data = step_one()?; // If step_one() fails, return its error now.
            let result = step_two(data)?; // If step_two() fails, return its error now.
            Ok(()) // Everything succeeded.
        }
        ```