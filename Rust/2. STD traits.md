
```
#[derive(?, ?, ?)] // What traits go here?
struct MyType { ... }
   ‚îÉ
   ‚î£‚îÅ‚îÅ üßê **Q: Can I print this for debugging?**
   ‚îÉ   ‚îó‚îÅ‚îÅ ‚úÖ **A: Yes, with `println!("{:?}", my_instance);`**
   ‚îÉ       ‚îó‚îÅ‚îÅ> derive `Debug`
   ‚îÉ
   ‚î£‚îÅ‚îÅ üìã **Q: Do I need to make copies of this value?**
   ‚îÉ   ‚î£‚îÅ‚îÅ ‚úÖ **A: Yes, and it's expensive (e.g., contains `String`, `Vec`).**
   ‚îÉ   ‚îÉ   ‚îó‚îÅ‚îÅ> derive `Clone`
   ‚îÉ   ‚îó‚îÅ‚îÅ ‚úÖ **A: Yes, and it's cheap (all fields are simple types like numbers, bools).**
   ‚îÉ       ‚îó‚îÅ‚îÅ> derive `Copy`, `Clone`  // Copy requires Clone
   ‚îÉ
   ‚î£‚îÅ‚îÅ ‚öñÔ∏è **Q: Do I need to compare instances?**
   ‚îÉ   ‚î£‚îÅ‚îÅ ‚úÖ **A: Yes, with `==` and `!=`.**
   ‚îÉ   ‚îÉ   ‚î£‚îÅ‚îÅ> derive `PartialEq`
   ‚îÉ   ‚îÉ   ‚îó‚îÅ‚îÅ ‚úÖ **Q: And is the equality total (no floating point NaN issues)?**
   ‚îÉ   ‚îÉ       ‚îó‚îÅ‚îÅ> derive `Eq`  // Eq requires PartialEq
   ‚îÉ   ‚îó‚îÅ‚îÅ ‚úÖ **A: Yes, with `<`, `>`, sorting, or finding min/max.**
   ‚îÉ       ‚î£‚îÅ‚îÅ> derive `PartialOrd`
   ‚îÉ       ‚îó‚îÅ‚îÅ ‚úÖ **Q: And is the ordering total (no floating point NaN issues)?**
   ‚îÉ           ‚îó‚îÅ‚îÅ> derive `Ord`  // Ord requires PartialOrd + Eq
   ‚îÉ
   ‚î£‚îÅ‚îÅ üîë **Q: Can I use this as a key in a `HashMap` or `HashSet`?**
   ‚îÉ   ‚îó‚îÅ‚îÅ ‚úÖ **A: Yes.**
   ‚îÉ       ‚îó‚îÅ‚îÅ> derive `Hash`  // Hash requires Eq
   ‚îÉ
   ‚îó‚îÅ‚îÅ üèóÔ∏è **Q: Do I need a "blank" or default instance?**
   ‚îÉ   ‚îó‚îÅ‚îÅ ‚úÖ **A: Yes, with `MyType::default();`**
   ‚îÉ       ‚îó‚îÅ‚îÅ> derive `Default`
   ‚îÉ
   ‚î£‚îÅ‚îÅ üëâ **Q: Does my type primarily WRAP another type and should it ACT like it?**
   ‚îÉ   ‚î£‚îÅ‚îÅ ‚úÖ **A: Yes, I want to use the `*` operator and have it auto-convert to a reference.**
   ‚îÉ   ‚îÉ   ‚î£‚îÅ‚îÅ> Implement `Deref<Target = InnerType>`
   ‚îÉ   ‚îÉ   ‚îó‚îÅ‚îÅ ‚úÖ **Q: And do I also need mutable access with `*`?**
   ‚îÉ   ‚îÉ       ‚îó‚îÅ‚îÅ> Implement `DerefMut`
   ‚îÉ   ‚îÉ
   ‚îÉ   ‚îó‚îÅ‚îÅ üí° **Use Case:** Creating smart pointers like `MyBox<T>` or a custom `MyString` that should be usable in functions expecting `&str`. This enables a powerful feature called **deref coercion**.
   ‚îÉ
   ‚î£‚îÅ‚îÅ üîÑ **Q: How should I CREATE my type from another type?**
   ‚îÉ   ‚î£‚îÅ‚îÅ ‚úÖ **A: The conversion can NEVER fail.**
   ‚îÉ   ‚îÉ   ‚îó‚îÅ‚îÅ> Implement `From<OtherType>`. (You get `Into` for free!)
   ‚îÉ   ‚îó‚îÅ‚îÅ ‚úÖ **A: The conversion MIGHT fail.**
   ‚îÉ       ‚îó‚îÅ‚îÅ> Implement `TryFrom<OtherType>`. (This returns a `Result`).
   ‚îÉ
   ‚îÉ
   ‚îó‚îÅ‚îÅ ‚úçÔ∏è **Q: Am I writing a FUNCTION that should flexibly accept different kinds of references to the same data?**
       ‚î£‚îÅ‚îÅ ‚úÖ **A: Yes, my function needs to READ FROM types like `String`, `&String`, or `&str`.**
       ‚îÉ   ‚îó‚îÅ‚îÅ> Make your function generic: `fn my_func<T: AsRef<str>>(arg: T)`
       ‚îó‚îÅ‚îÅ ‚úÖ **A: Yes, and my function needs to MUTATE those types.**
           ‚îó‚îÅ‚îÅ> Make your function generic: `fn my_func<M: AsMut<str>>(arg: &mut M)`
```

### Marker traits
```
MyType { ... } // What properties does my type have?
   ‚îÉ
   ‚î£‚îÅ‚îÅ üß† **Q: Does the compiler know the exact size of my type?**
   ‚îÉ   ‚îó‚îÅ‚îÅ ‚úÖ **A: Yes.**
   ‚îÉ       ‚îó‚îÅ‚îÅ> Your type is automatically `Sized`. You only worry about this when you're working with a type that *isn't* `Sized`, like `str` or `[T]`.
   ‚îÉ
   ‚îó‚îÅ‚îÅ üßµ **Q: Will this type be used across multiple threads?**
       ‚î£‚îÅ‚îÅ ‚úÖ **A: Yes, and all its fields are already thread-safe (like `i32`, `String`, `Arc`).**
       ‚îÉ   ‚îó‚îÅ‚îÅ> Your type will automatically be `Send` and `Sync`. You don't need to do anything.
       ‚îó‚îÅ‚îÅ üíÄ **A: Yes, but it contains non-thread-safe types (like `Rc` or raw pointers), and I will personally guarantee its safety.**
           ‚î£‚îÅ‚îÅ> To move it to another thread: `unsafe impl Send for MyType`
           ‚îó‚îÅ‚îÅ> To share references (`&MyType`) across threads: `unsafe impl Sync for MyType`
```

### Cheat Sheet of Common Operator Traits

| Operator(s)        | Trait(s) to Implement           | Example Method Signature                                   |
| ------------------ | ------------------------------- | ---------------------------------------------------------- |
| **Arithmetic**     |                                 |                                                            |
| `+`                | `Add`                           | `fn add(self, rhs: Self) -> Self::Output`                  |
| `-`                | `Sub`                           | `fn sub(self, rhs: Self) -> Self::Output`                  |
| `*`                | `Mul`                           | `fn mul(self, rhs: Self) -> Self::Output`                  |
| `/`                | `Div`                           | `fn div(self, rhs: Self) -> Self::Output`                  |
| `+=`, `-=` etc.    | `AddAssign`, `SubAssign`, etc.  | `fn add_assign(&mut self, rhs: Self)`                      |
| **Unary**          |                                 |                                                            |
| `-` (negation)     | `Neg`                           | `fn neg(self) -> Self::Output`                             |
| `!` (boolean not)  | `Not`                           | `fn not(self) -> Self::Output`                             |
| **Indexing**       |                                 |                                                            |
| `[]`               | `Index` (for immutable access)  | `fn index(&self, index: Idx) -> &Self::Output`             |
| `[]`               | `IndexMut` (for mutable access) | `fn index_mut(&mut self, index: Idx) -> &mut Self::Output` |
| **Dereferencing**  |                                 |                                                            |
| `*` (dereference)  | `Deref`, `DerefMut`             | `fn deref(&self) -> &Self::Target`                         |
| **Function Calls** |                                 |                                                            |
| `()`               | `Fn`, `FnMut`, `FnOnce`         | (Advanced: usually for closures)                           |

## A Visual Guide to Rust's Standard Traits

### ü™Ñ Part 1: The `#[derive]` Traits (Getting "Free" Functionality)

These are the traits you ask the compiler to automatically implement for you. They provide common, essential behaviors to your `struct`s and `enums`.

- **Debugging & Display**
    - **`Debug`**: Allows your type to be printed with the `{:?}` formatter for developer output.
- **Value Management**
    - **`Clone`**: Gives your type a `.clone()` method for explicit, potentially expensive duplication.
    - **`Copy`**: A marker for types that are cheap to duplicate with a simple bit-for-bit copy. But must require `Clone` with it.
- **Comparisons**
    - **`PartialEq`** / **`Eq`**: Allows your type to be compared for equality with `==` and `!=`.
    - **`PartialOrd`** / **`Ord`**: Allows your type to be sorted and compared with `<`, `>`, etc.
- **Hashing**
    - **`Hash`**: Allows an instance of your type to be used as a key in a `HashMap` or stored in a `HashSet`.
- **Default Values**
    - **`Default`**: Gives your type a `::default()` method to create a "blank" or default instance.
---
### ü¶æ Part 2: The `impl` Traits (Defining Custom Behavior)

These are traits you typically implement manually to give your types unique "superpowers" and integrate them more deeply with the language's idioms.

- **Smart Pointer Behavior**
    - **`Deref`** / **`DerefMut`**: Allows your type to act like a smart pointer by overloading the `*` operator and enabling deref coercion.
    - **`Drop`**: Allows you to define custom cleanup logic that runs when your type goes out of scope.
- **Operator Overloading (`std::ops`)**
    - **`Add`**, **`Sub`**, **`Mul`**, etc.: Overload the arithmetic operators (`+`, `-`, `*`).
    - **`Index`** / **`IndexMut`**: Overload the indexing operator (`[]`).
    - **`Neg`**, **`Not`**: Overload the unary operators (`-`, `!`).
- **Conversion & Flexibility**
    - **`From`** / **`Into`**: The idiomatic way to handle infallible type conversions.
    - **`TryFrom`** / **`TryInto`**: For fallible (error-able) type conversions.    
    - **`AsRef`** / **`AsMut`**: Allows for cheap, reference-to-reference conversions, making functions more flexible.
---
### üèóÔ∏è Part 3: The Core Abstraction Traits (The Language's Building Blocks)

These fundamental traits define the core interfaces of the language. You use them constantly as trait bounds, but you only implement them for very specific types.

- **Iteration**
    - **`Iterator`**: The foundation for all loops and data processing. Implementing this lets your type be used in a `for` loop.
- **Asynchronous Operations**
    - **`Future`**: The core of `async`/`await`, representing a value that will be available later.
- **Input/Output (`std::io`)**
    - **`Read`** / **`Write`**: Universal traits for reading from and writing to sources like files and network streams.
- **Formatting (`std::fmt`)**
    - **`Display`**: For user-facing, "pretty" printing with the `{}` formatter.
- **Error Handling (`std::error`)**
    - **`Error`**: The base trait for creating custom, composable error types.
---
### üè∑Ô∏è Part 4: The Marker Traits (Signals to the Compiler)

These special traits have no methods. They "mark" a type with a property, which the compiler uses to enforce safety rules. Most are added automatically.

- **Sizing**
    - **`Sized`**: Marks a type whose size is known at compile time (most types). You only think about its absence (`?Sized`) for DSTs.
- **Concurrency**
    - **`Send`**: Marks a type that can be safely moved to another thread.
    - **`Sync`**: Marks a type that can be safely shared (`&T`) between threads.
- **Pinning (`async`)**
    - **`Unpin`**: Marks a type that is safe to move in memory even after being pinned (most types). Its absence is important for `async` code.
- **Panic Safety**
    - **`UnwindSafe`**: Marks a type as safe to use across a panic boundary.