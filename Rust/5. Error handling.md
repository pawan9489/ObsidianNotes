Two main error types:

- **Recoverable errors:** These are errors that can be reasonably expected and handled, such as a file not being found or a network request failing. Rust uses the
    `Result<T, E>` type for these.
- **Unrecoverable errors:** These are unexpected bugs, like an index being out of bounds, where the program cannot safely continue. Rust uses the
    `panic!` macro to handle these by terminating the program.
### Error actions in rust

| Action               | Primary Tool(s)                | Example / Use Case                                         |
| :------------------- | :----------------------------- | :--------------------------------------------------------- |
| **Create Error**     | `Result::Err(value)`           | `return Err(MyError::ConnectionFailed);`                   |
| **Create "Absence"** | `Option::None`                 | `return None;` // When a value might not exist.            |
| **Handle Error**     | `match` expression             | `match my_func() { Ok(v) => ..., Err(e) => ... }`          |
| **Propagate Error**  | `?` operator                   | `let value = my_func()?;`                                  |
| **Panic on Error**   | `.unwrap()` / `.expect("msg")` | `let value = my_func().expect("This should never fail!");` |
### Error trait & types
- **The Trait: `std::error::Error`** This is the universal "contract" or "interface" that says, "This type is a standard error." It's an abstract concept.
- **The Concrete Types: `std::io::Error`, `std::num::ParseIntError`** etc., These are specific **structs** that represent a particular kind of failure (an I/O error, a parsing error). They are concrete types that _implement_ the `std::error::Error` trait.

Here are a few error types in the standard library you'll use most often, grouped by the module they come from.
#### `std::io`
- **`io::Error`**
    - **When you'll see it:** This is arguably the most common error type you'll encounter. It's returned by almost every function that deals with input or output.
    - **What it means:** Something went wrong with an I/O operation, such as a file not being found, a network connection being refused, or not having permission to read a file.
---
#### `std::num`
- **`num::ParseIntError`**
    - **When you'll see it:** When calling `.parse::<i32>()` or any other integer type on a string.
    - **What it means:** The string did not contain a valid integer (e.g., you tried to parse `"hello"` as a number).
- **`num::ParseFloatError`**
    - **When you'll see it:** When calling `.parse::<f64>()` on a string.
    - **What it means:** The string did not contain a valid floating-point number.
---
#### `std::string` and `std::str`
- **`string::FromUtf8Error`**
    - **When you'll see it:** When converting a vector of bytes (`Vec<u8>`) into a `String` using `String::from_utf8()`.
    - **What it means:** The sequence of bytes was not a valid UTF-8 encoding.
- **`str::ParseBoolError`**
    - **When you'll see it:** When calling `.parse::<bool>()` on a string.
    - **What it means:** The string was not `"true"` or `"false"`.
---
#### `std::sync`
- **`sync::PoisonError`**
    - **When you'll see it:** When you call `.lock()` on a `Mutex` or `RwLock` after another thread has panicked while holding the lock.
    - **What it means:** The lock is "poisoned" to warn you that the data it protects might be in a corrupt, inconsistent state.
---
#### `std::fmt`
- **`fmt::Error`**
    - **When you'll see it:** When implementing the `Display` or `Write` traits, or using macros like `write!`.
    - **What it means:** A formatting or writing operation failed, for example, if the underlying writer returned an error.
---
### Custom error handling using std lib
```rust
use std::error::Error;
use std::fmt;

// 1. Define a custom error enum to represent all possible failures.
#[derive(Debug)]
enum ParseDataError {
    Empty, // For when the input string is empty
    Malformed(String), // For when the data has the wrong format
}

// 2. Implement the `Display` trait to provide user-friendly error messages. 
impl fmt::Display for ParseDataError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ParseDataError::Empty => write!(f, "Cannot parse an empty string"),
            ParseDataError::Malformed(data) => write!(f, "Malformed data found: {}", data),
        }
    }
}

// 3. Implement the `Error` trait to mark this type as a standard error. 
// This makes it compatible with other error-handling utilities.
impl Error for ParseDataError {}

// 4. Create a function that returns our custom error type.
fn parse_positive_number(s: &str) -> Result<u32, ParseDataError> {
    if s.is_empty() {
        return Err(ParseDataError::Empty);
    }
    
    match s.parse::<u32>() {
        Ok(number) => Ok(number),
        Err(_) => Err(ParseDataError::Malformed(s.to_string())),
    }
}

// Extra:: For having error propagation using `?` operator we need to have
// impl From<so_n_so_error> for ParseDataError converters.

// 5. Use the function and handle the custom error.
fn main() {
    let inputs = ["42", "", "abc"];

    for input in inputs {
        println!("Parsing '{}'...", input);
        match parse_positive_number(input) {
            Ok(number) => println!("Success! Number is {}.", number),
            Err(e) => eprintln!("Error: {}", e),
        }
    }
}
```

### How to Keep an Executable Running After a Panic
The default behavior when a thread panics is for it to **unwind** its stack (running destructors to clean up) and then terminate. If this is the main thread, your entire program exits.

To prevent this, you can wrap a fallible operation in `std::panic::catch_unwind`. This function acts as a boundary. If the code inside the closure panics, `catch_unwind` will catch the panic and return an `Err`, allowing the parent thread to continue running.

```rust
use std::panic;

fn this_panics() {
    panic!("This is a deliberate panic!");
}

fn main() {
    println!("About to call a function that will panic...");

    // We wrap the call in `catch_unwind`.
    let result = panic::catch_unwind(|| {
        this_panics();
    });
    // We check the result.
    match result {
        Ok(_) => println!("This will never be printed."),
        Err(_) => eprintln!("Caught a panic! But the program can continue."),
    }
    println!("Program finished gracefully instead of crashing.");
}
```

Modern Rust web frameworks like **`actix-web`** and **`axum`** are built to be resilient. Here's how they typically work:
1. The main server process listens for incoming connections.
2. When a new request comes in, the framework spawns a new asynchronous task to handle it.
3. Crucially, the framework wraps the call to _your_ request handler code (the part that could panic) inside its own `catch_unwind` boundary.
4. If your handler code panics, the framework catches it. It will stop that single task, log the error, and typically send a generic "500 Internal Server Error" response to that specific client.
---

#### The `UnwindSafe` Trait

Catching a panic introduces a new problem: what if the panic happened while data was being modified, leaving it in a broken, inconsistent state? This is known as a lack of **panic safety**.

The `UnwindSafe` trait is a **marker trait** used to signal that a type is safe to use across a panic boundary. It's a promise that if a panic occurs during an operation involving this type, the type won't be left in a logically corrupt state.

- **What is `UnwindSafe`?** Most primitive types like `i32` and `String` are `UnwindSafe`. A shared reference `&T` is safe if `T` itself is `RefUnwindSafe`.
- **What is NOT `UnwindSafe`?** The most important example is a `MutexGuard`. If a thread panics while holding a lock, the `Mutex` becomes **poisoned**. This is a safety feature that prevents other threads from locking the mutex and observing the corrupted data. Other types that use interior mutability, like `RefCell`, are also not `UnwindSafe`.

The `catch_unwind` function requires the closure it runs to be `UnwindSafe`. This is a compile-time check that forces you to consider whether your data will be valid after a potential panic.

One way to useÂ `AssertUnwindSafe`Â is to assert that the entire closure itself is unwind safe, bypassing all checks for all variables:

```rust
fn main() {
    use std::panic::{self, AssertUnwindSafe};
    
    let mut variable = 4;
    
    // This code will not compile because the closure captures `&mut variable`
    // which is not considered unwind safe by default.
    
    panic::catch_unwind(|| {
        variable += 3;
    });
    
    // This, however, will compile due to the `AssertUnwindSafe` wrapper
    // let result = panic::catch_unwind(AssertUnwindSafe(|| {
    //     variable += 3;
    // }));
}
```


### Using crates for error handling
1. **Structured errors** are custom `enum`s or `struct`s that represent a specific and finite set of possible failures. This approach, often implemented with the help of the `thiserror` crate, is ideal for **library code**. By defining a precise error type, a library provides a clear, predictable API contract that allows the calling code to `match` on different error variants and handle each failure in a unique, programmatic way. This enables robust error recovery and makes the library's behavior transparent to its users.
2. **Dynamic errors**, on the other hand, use a "type-erased" wrapper like `Box<dyn Error>` or `anyhow::Error` to handle diverse error kinds in a uniform way. This approach is best suited for **application code**, such as in your `main.rs` or top-level business logic. At this level, you often don't need to handle every specific error from every library you call. Instead, your goal is to add high-level context to any failure, log it for debugging, and present a clean message to the user. Dynamic errors simplify this process by eliminating the need to create new, large `enum`s just to combine errors from different sources.
### `thiserror` crate

**Core Purpose:** A tool for library authors to create detailed, custom error `enum`s with minimal boilerplate. It uses macros to automatically generate

`Display`, `Error`, and `From` trait implementations.

#### Key Macro Attributes
- **`#[derive(Error)]`**: The main derive macro that enables all of `thiserror`'s functionality.
- **`#[error("...")]`**: Defines the user-facing message for an error variant, automatically generating the `Display` trait implementation.
- **`#[from]`**: Used on a variant with a single field to automatically generate an `impl From<...>` for that error type. This also implements the `source()` method, making it work seamlessly with error chaining and the `?` operator.    
- **`#[source]`**: Explicitly marks a field within a variant as the underlying error source for the `Error::source()` method. This is used when you are not using `#[from]`.
#### Common Patterns

##### 1. Simple Error Variant

For errors that don't wrap another error.
```rust
#[derive(Error, Debug)]
pub enum MyError {
    #[error("The provided ID is invalid")]
    InvalidId,
}
```

##### 2. Simple Wrapping with `#[from]`

For transparently wrapping an external error.
```rust
#[derive(Error, Debug)]
pub enum MyError {
    // This gives you `impl From<std::io::Error> for MyError` for free.
    #[error("An I/O error occurred")]
    Io(#[from] std::io::Error),
}
```

##### 3. Adding Context with `#[source]`

For creating a new error that adds context to an underlying error. You **cannot** use `#[from]` in this case because you need to provide the extra context manually.
```rust
#[derive(Error, Debug)]
pub enum MyError {
    #[error("Failed to read config from '{filename}'")]
    ReadConfig {
        filename: String,
        #[source] // Marks the underlying cause
        source: std::io::Error,
    },
}
```

##### Rules & Limitations
- You can only use `#[from]` on a variant that contains a **single field**.
- You cannot use the same `#[from]` source type (e.g., `std::io::Error`) on multiple different variants of the same `enum`, as the conversion would be ambiguous.

```rust
use std::num::ParseIntError;
use thiserror::Error; // 2.0.12

#[derive(Error, Debug)]
enum ParseError<'a>{
    #[error("Cannot parse empty string.")]
    Empty,
    
    #[error("{input} string cannot be converted into u32")]
    Invalid {
        input: &'a str,
        #[source]
        source: ParseIntError,
    },
}

fn parse_inputs<'a>(inputs: &'a [&'a str]) -> Vec<Result<u32, ParseError<'a>>> {
    inputs
        .iter()
        .map(|&x| {
            if x.is_empty() {
                Err(ParseError::Empty)
            } else {
                x.parse::<u32>().map_err(|e| ParseError::Invalid {
                    input: x,
                    source: e,
                })
            }
        })
        .collect()
}

fn log_errors<'a>(results: &[Result<u32, ParseError<'a>>]) {
    results
        .iter()
        .filter_map(|res| res.as_ref().err())
        .for_each(|e| eprintln!("{e}"));
}

fn main() {
    let inputs = ["42", "", "abc"];
    let results = parse_inputs(&inputs);
    dbg!(&results);
    /*
	    [src/main.rs:45:5] &results = [
		    Ok(
		        42,
		    ),
		    Err(
		        Empty,
		    ),
		    Err(
		        Invalid {
		            input: "abc",
		            source: ParseIntError {
		                kind: InvalidDigit,
		            },
		        },
		    ),
		]
	*/
    log_errors(&results);
    // Cannot parse empty string.
	// abc string cannot be converted into u32
}
```

#### `thiserror` vs. `std` Library Comparison

Here is a side-by-side example showing how `thiserror` reduces the boilerplate required when creating a custom error type compared to using only the standard library. Both implementations produce an error type with the exact same behavior.

```rust
use std::error::Error;
use std::fmt;

// --- MODULE 1: The Manual Implementation (using only `std` traits) ---
mod manual {
    use super::*; // Make parent imports available

    #[derive(Debug)]
    pub enum DataParseError {
        Empty,
        Malformed(String),
    }

    // Manually implement `Display` to define user-facing error messages [cite: 3189]
    impl fmt::Display for DataParseError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                DataParseError::Empty => write!(f, "Cannot parse an empty string"),
                DataParseError::Malformed(data) => write!(f, "Malformed data found: '{}'", data),
            }
        }
    }

    // Manually implement the `Error` trait to mark this as a standard error [cite: 3188]
    impl Error for DataParseError {}
}


// --- MODULE 2: The `thiserror` Implementation ---
mod with_thiserror {
    use super::*;
    use thiserror::Error; // Import the derive macro

    #[derive(Error, Debug)]
    pub enum DataParseError {
        // The #[error] attribute generates the `Display` impl automatically
        #[error("Cannot parse an empty string")]
        Empty,

        #[error("Malformed data found: '{0}'")]
        Malformed(String),
    }
}

// --- Main function to demonstrate both error types ---
fn main() {
    let manual_error = manual::DataParseError::Malformed("abc".to_string());
    let thiserror_error = with_thiserror::DataParseError::Malformed("abc".to_string());

    // Both error types produce the same user-friendly output because `thiserror`
    // generated the same `Display` implementation for us.
    println!("Manual error says: {}", manual_error);
    println!("thiserror error says: {}", thiserror_error);
}
```
### `anyhow` Crate

**Core Purpose:** `anyhow` is the ideal error handling tool for **application code** (e.g., your `main.rs`, binaries, and business logic). Its goal is to make error propagation and logging easy by using a single, universal error type and providing powerful tools to add context.

**Analogy: The Universal Shipping Container ðŸ“¦** Think of `anyhow::Error` as a universal shipping container. It can hold any kind of specific error (from a library or `std`). Its real power comes from the `.context()` method, which is like adding a new shipping label to the outside of the container at each step of its journey. When something goes wrong, you can read the labels to get the full story of where it's been.

#### Key Types & Traits to `use`
- **`anyhow::Result<T>`**: The standard return type for fallible functions in your application. It's an alias for `Result<T, anyhow::Error>`.
- **`anyhow::Context`**: An extension trait that provides the `.context()` and `.with_context()` methods for `Result` and `Option`.
#### Core Features
- **Unified Error Type**: `anyhow::Error` is a "type-erased" wrapper that can hold any error type implementing `std::error::Error`. This means you don't need to create new `enum`s just to handle different error sources.
- **Contextual Chaining**: The `.context()` method wraps an existing error with an additional, descriptive message. This is the primary way you build an error chain. When the error is finally printed, `anyhow` displays this chain of contexts, from the highest-level operation down to the root cause.
- **Ad-Hoc Errors**: You can create a new error on the fly from a string using the `anyhow!` macro (e.g., `return Err(anyhow!("Invalid input provided"));`).
---
#### Example: A Multi-Step Process with Chaining

This example shows a function that performs several steps, each of which can fail. We'll use `.context()` at each step to build a clear error chain. We will simulate a failure at the very first step.

```rust
use anyhow::{Context, Result};
use std::fs;
use std::error::Error;

// This is our main application logic function.
// Notice it returns a single, simple `anyhow::Result`.
fn run_app() -> Result<()> {
    // --- Step 1: Read a configuration file ---
    let config = fs::read_to_string("app_config.txt")
        .context("Failed to read the application configuration file")?;

    // --- Step 2: Parse a setting from the config ---
    let user_id: u32 = config.trim().parse()
        .context("Failed to parse 'user_id' from the config file")?;

    // --- Step 3: Use the setting to do something else ---
    // (This step won't be reached in our failure example)
    println!("Successfully processed config for user_id: {}", user_id);

    Ok(())
}

fn main() {
    println!("Starting application...");

    // We call our main logic and handle any potential failure.
    if let Err(e) = run_app() {
        // The `anyhow` error's Debug format is specially designed
        // to print the entire chain of context beautifully.
        eprintln!("\nFATAL ERROR: A problem occurred during startup.");
        eprintln!("{:?}", e);
    }
}
```
#### Expected Output
Since the file `app_config.txt` does not exist, the program will fail at the very first step. The `.context()` message will wrap the underlying `std::io::Error`, and `anyhow` will format it into this detailed report:

```
Starting application...

FATAL ERROR: A problem occurred during startup.
Error: Failed to read the application configuration file

Caused by:
    No such file or directory (os error 2)
```

As you can see, the output provides the full story:

1. **The High-Level Context (from `.context()`):** "Failed to read the application configuration file". This tells you _what_ your application was trying to do.
2. **The Root Cause (from `std::io::Error`):** "No such file or directory". This tells you the specific, low-level reason for the failure.
#### Example 1: The Cascading Enum Problem (with `thiserror`) vs `anyhow`

This example shows how, without a dynamic error type, you are forced to create new, larger error `enum`s at each layer of your application just to combine errors from the layers below.

**The Scenario:** We have a database layer and a logic layer. The logic layer needs to handle its own errors _and_ all possible errors from the database layer.

```rust
use thiserror::Error;
use std::io;

// --- Layer 1: A low-level "database" module ---
mod db {
    use super::*; // Make parent imports available

    #[derive(Error, Debug)]
    pub enum DbError {
        #[error("User ID {0} not found")]
        UserNotFound(u32),
        #[error("Database connection failed")]
        ConnectionError,
    }

    // This function returns our specific, structured error.
    pub fn find_user(id: u32) -> Result<String, DbError> {
        if id == 42 {
            Ok("Alice".to_string())
        } else {
            Err(DbError::UserNotFound(id))
        }
    }
}


// --- Layer 2: A "business logic" module ---
mod logic {
    use super::*;

    // THE PAIN POINT: We must create a NEW, larger error enum
    // just to combine our own errors with the errors from the `db` module.
    #[derive(Error, Debug)]
    pub enum LogicError {
        #[error("A database error occurred")]
        Database(#[from] db::DbError),

        #[error("A configuration file error occurred")]
        ConfigFile(#[from] io::Error),
    }

    // This function calls the DB and also does its own I/O.
    pub fn get_processed_user(id: u32) -> Result<String, LogicError> {
        // This `?` works because `LogicError` has `#[from] db::DbError`.
        let username = db::find_user(id)?;
        
        // This `?` works because `LogicError` has `#[from] io::Error`.
        let config = std::fs::read_to_string("config.txt")?;

        Ok(format!("Config for {}: {}", username, config))
    }
}


fn main() {
    // This call can fail with either a DbError or an io::Error,
    // both wrapped inside the `logic::LogicError` enum.
    match logic::get_processed_user(101) {
        Ok(data) => println!("Success: {}", data),
        Err(e) => eprintln!("Error: {}", e),
    }
}
```

#### What this Demonstrates

This pattern is very verbose. Imagine a third layer that calls `logic::get_processed_user()` but can _also_ fail with a network error. You would need to create a `TopLevelError` enum that wraps `logic::LogicError` and `reqwest::Error`. This "cascading" or "nesting" of enums is the exact boilerplate that `anyhow` eliminates in application code.

---
#### Example 2: The `std` `Box<dyn Error>` Context Problem

This example shows the standard library's way to handle heterogeneous errors. It works, but it loses all context about _what_ your program was trying to do.

**The Scenario:** A function reads a number from a file. This can fail by not finding the file (`io::Error`) or by the file containing invalid text (`ParseIntError`).

```rust
use std::error::Error;
use std::fs;

// This function uses the standard library's "dynamic error" type.
fn get_important_number_from_file(path: &str) -> Result<i32, Box<dyn Error>> {
    // The `?` automatically converts both `io::Error` and `ParseIntError`
    // into a `Box<dyn Error>`.
    let content = fs::read_to_string(path)?;
    let number = content.trim().parse::<i32>()?;
    Ok(number)
}

fn main() {
    // --- Failure Case 1: File does not exist ---
    println!("--- Attempting to read from a missing file ---");
    match get_important_number_from_file("missing.txt") {
        Ok(num) => println!("Number is: {}", num),
        Err(e) => {
            // THE PAIN POINT: The error is correct, but has no context.
            // We just know a file wasn't found, but not *why* it was important.
            eprintln!("Error: {}", e);
        }
    }

    println!("\n--- Attempting to read a malformed file ---");
    fs::write("malformed.txt", "not-a-number").unwrap();
    
    // --- Failure Case 2: File has bad data ---
    match get_important_number_from_file("malformed.txt") {
        Ok(num) => println!("Number is: {}", num),
        Err(e) => {
            // THE PAIN POINT: Again, the error is technically correct,
            // but we've lost all context about what we were trying to do.
            eprintln!("Error: {}", e);
        }
    }

    fs::remove_file("malformed.txt").unwrap();
}
```

#### What this Demonstrates

The `Box<dyn Error>` correctly unifies the different error types. However, the error messages are unhelpful to an end-user or for debugging. You get `"No such file or directory"` but you don't know that you were trying to "read the important number for configuration."

This is the exact problem `anyhow`'s `.context()` method is designed to solve. It allows you to wrap these low-level, generic errors with high-level, human-readable descriptions of your intent.