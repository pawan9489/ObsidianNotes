# Toolchain setup

### Table 1: Package Versioning Comparison

| Feature                                | Haskell                                                                                                                                                                                                 | Rust                                                                                                                                                                                                                            |
|:---------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Policy/Standard**                    | **Package Versioning Policy (PVP)**: Typically `A.B.C` (interpreted as `MAJOR1.MAJOR2.MINOR` for API changes, plus `PATCH`). `0.x` versions provide same guarantees as `1.x+`.                          | **Semantic Versioning (SemVer)**: `MAJOR.MINOR.PATCH`. `0.x` versions imply API instability; caret `^` treats `0.A.B` compatible with `0.A.C` (`C >= B`).                                                                       |
| **Core Tools**                         | `cabal-install` (Cabal CLI), `Stack` (build tool emphasizing reproducible builds via snapshots)                                                                                                         | `cargo` (build system and package manager)                                                                                                                                                                                      |
| **Manifest File**                      | `<package-name>.cabal` (defines package properties, dependencies). `package.yaml` (Hpack format, generates `.cabal`). `stack.yaml` (Stack project config, specifies resolver/snapshot).                 | `Cargo.toml` (defines package metadata, dependencies, workspace configuration)                                                                                                                                                  |
| **Lock File / Reproducibility**        | `cabal.project.freeze` (Cabal). Stack ensures reproducibility via snapshots (e.g., LTS, Nightly) and `stack.yaml.lock` for custom snapshot dependencies.                                                | `Cargo.lock` (records exact versions of all dependencies, ensuring reproducible builds by default).                                                                                                                             |
| **Key System Dependencies**            | `base` (core libraries, version tightly coupled with GHC version), `ghc-prim` (compiler primitives).                                                                                                    | `std` (standard library, versioned with the Rust compiler itself).                                                                                                                                                              |
| **Dependency Specification**           | Version bounds in `.cabal` files (e.g., `base >= 4.14 && < 4.15`, `text ^>= 1.2.5`).                                                                                                                    | Version requirements in `Cargo.toml` (e.g., `rand = "0.8.5"` which implies `^0.8.5`, also `~`, `=`, `*`).                                                                                                                       |
| **Resolution Strategy**                | Cabal's solver finds a consistent build plan based on constraints. Stack uses curated package sets (snapshots) and allows `extra-deps`.                                                                 | Cargo's resolver finds the newest SemVer-compatible versions. Can allow multiple _compatible_ versions of the same crate if they don't conflict in the dependency graph, but typically one version per crate.                   |
| **Conflict Indication**                | Historically "Cabal hell" (much improved). Solver will error if no consistent plan found. Stack greatly reduces this with snapshots.                                                                    | Cargo build will fail with errors detailing conflicting version requirements.                                                                                                                                                   |
| **Example: `text 2.0` Issue (User's)** | `text 2.0` required a newer `base` (and thus GHC version) than the user's environment provided, causing a conflict. Resolved by aligning `text` version with the GHC/snapshot or updating GHC/snapshot. | Hypothetical: If `mylib v1` needs `some_crate = "1.0"` and `mylib v2` needs `some_crate = "2.0"`, adding `mylib v2` could cause Cargo to error if both are direct dependencies with incompatible requirements for `some_crate`. |

### Table 2: Dynamic Linking Comparison

| Feature                                           | Haskell (GHC)                                                                                                                                                                        | Rust (rustc/Cargo)                                                                                                                                                             |
|:--------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Dynamic Linking Support**                       | Yes (`-dynamic`, `-shared` flags). Can create/use `.so` (Linux), `.dylib` (macOS), `.dll` (Windows).                                                                                 | Yes. `dylib` crate type for Rust-to-Rust dynamic linking. `cdylib` crate type for C-compatible dynamic libraries (standard for FFI).                                           |
| **Default Linking Behavior**                      | Often static for development builds and application deployment for simplicity. Some OS distributions (e.g., Arch Linux) package Haskell libraries dynamically.                       | Strongly prefers static linking for Rust dependencies (`rlib` files) into executables by default.                                                                              |
| **ABI Stability**                                 | **Unstable** native Haskell ABI. Dynamically linked Haskell libraries/executables may break if dependencies change; recompilation often needed.                                      | **Unstable** native Rust ABI (for `dylib`). Generics & monomorphization make this hard. **Stable C ABI** when using `cdylib`.                                                  |
| **Primary Reason for Default**                    | ABI instability makes static linking more robust for most use cases. Ensures all dependencies are bundled.                                                                           | ABI instability (Rust-to-Rust), performance benefits of static linking and monomorphization, ease of distributing self-contained binaries.                                     |
| **Handling Multiple Lib Versions (System Level)** | For C libraries Haskell links against, OS uses SONAMEs. For Haskell dynamic libs, build tools aim for one version per build plan. Multiple distinct `libHS<Pkg>-<Ver>.so` can exist. | For C libraries Rust links against (via `cdylib`), OS uses SONAMEs. Cargo resolves Rust deps at build time, usually to one version.                                            |
| **`.so` Versioning (e.g., Fedora)**               | Yes, for C libraries. Haskell libraries packaged by OS may follow system conventions (e.g., `libHSmypackage-1.2.3-xyz.so`).                                                          | Yes, for C libraries. `cdylib`s can be versioned like C `.so` files (e.g., `libmyrustlib.so.1`) if deployed as system libraries. `dylib` not typical for this.                 |
| **Main Use Cases for Dynamic**                    | GHCi (interactive interpreter), plugin systems, OS-level package distribution where shared resources are beneficial, FFI with C.                                                     | FFI via `cdylib` (most common: interfacing with C/C++, Python, etc.), plugin systems (often via `cdylib` or ABI-stable wrappers). `dylib` is rare.                             |
| **Versioning Info in `.so` file**                 | GHC embeds package ID (name-version-hash) in symbols. OS-level SONAME versioning not automatic for Haskell ABI itself but can be applied by packagers.                               | `Cargo.toml` version info not typically embedded as OS-level versioning (e.g. SONAME for ELF) in `dylib`/`cdylib` by default, though possible for `cdylib` via linker options. |

### Table 3: Inlining with Dynamic Linking

| Aspect                                                                                            | General Concept                                                                                                                                                                                                           | Haskell (GHC) Specifics                                                                                                                                                                                         | Rust (rustc/LLVM) Specifics                                                                                                                                                                                                              |
|:--------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Inlining _within_ a single module/compilation unit** (e.g., within one `.so` or one executable) | **Yes, extensively.** Compilers aggressively inline functions defined and called within the same module they are currently compiling for optimization.                                                                    | **Yes, extensively.** GHC performs significant inlining within a Haskell package/module during its compilation, even if that package becomes a shared library.                                                  | **Yes, extensively.** `rustc` (via LLVM) performs aggressive inlining within a single crate during its compilation, whether the output is an executable, `rlib`, `dylib`, or `cdylib`.                                                   |
| **Inlining _across_ dynamic library boundaries (traditional, at caller's compile time)**          | **Generally No.** The caller's compiler usually only sees the declaration (signature) of a function in a separate dynamic library, not its full definition/body, so it cannot inline it. The call is resolved at runtime. | **Can occur (effectively).** GHC's interface files (`.hi`) can contain "unfoldings" (compact representations of function bodies). The compiler can use these to inline calls from dependencies at compile time. | **Generally No** for opaque calls (e.g., `extern "C"` function in a `cdylib`, or a non-generic function in a `dylib` if only signature is known).                                                                                        |
| **Link-Time Optimization (LTO)**                                                                  | **Can enable** inlining across module boundaries if the LTO process can analyze both the caller and callee code together, even if they are in separate files destined for dynamic linking.                                | GHC has its own whole-program optimization philosophy; cross-package optimization is often more integrated via interface files than a separate LTO linker pass in the C++ sense.                                | **Yes, with `-C lto`.** LTO can enable inlining across different crates if they are linked together in a process that LTO can optimize, potentially including `dylib` scenarios if set up carefully.                                     |
| **Other Relevant Factors**                                                                        | visibility of function definitions.                                                                                                                                                                                       | Richness of `.hi` interface files (containing unfoldings) is key.                                                                                                                                               | Monomorphization of generics: generic functions from a library are specialized for concrete types in the calling crate. If the generic definition is available (e.g., via metadata), this specialized code can be inlined in the caller. |

### Haskell Tutorials

- IOG Academy - https://www.youtube.com/playlist?list=PLNEK_Ejlx3x1D9Vq5kqeC3ZDEP7in4dqb
- Advanced Haskell programming - https://www.youtube.com/playlist?list=PLF1Z-APd9zK5uFc8FKr_di9bfsYv8-lbc
- Haskell for imperative programmers - https://www.youtube.com/playlist?list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV
- Serokell - https://www.youtube.com/playlist?list=PLvKo-zX3IKZGhrO15dmzq7StLSIP067tk
- Rust Quiz: https://github.com/dtolnay/rust-quiz

| Category                                          | Description/Purpose                                                                                                                                          | Rust Library Examples                                                                                                                                                              | Haskell Library Examples                                                                                                                                                                                    |
|:--------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **1. Core Data Structures & Algorithms**          | Beyond standard collections: high-performance, concurrent, probabilistic structures, graph algorithms, advanced sorting/searching.                           | `std::collections`, `itertools`, `ndarray`, `petgraph`, `rayon` (parallel iterators), `concurrent-queue`, `im` / `rpds` (persistent data structures), `hashbrown` (faster HashMap) | `containers` (Map, Set, Sequence), `vector` (performant arrays), `unordered-containers` (HashMap), `massiv` (multidimensional arrays), `fgl` (graphs), `dlist`, `psqueues` (priority queues), `bloomfilter` |
| **2. Parsing & Formal Languages**                 | Lexing, parsing complex grammars (text/binary), Abstract Syntax Tree (AST) manipulation, compiler construction toolkits.                                     | `nom`, `chumsky`, `pest`, `lalrpop`, `regex`                                                                                                                                       | `megaparsec`, `attoparsec`, `alex` (lexer), `happy` (parser generator), `trifecta`, `Earley`, `BNFC`                                                                                                        |
| **3. Serialization & Data Exchange**              | Efficiently converting data to/from various formats (JSON, YAML, TOML, Protobuf, Cap'n Proto, Avro, MessagePack), schema definition & evolution, RPC.        | `serde` (framework), `serde_json`, `serde_yaml`, `toml`, `prost`/`tonic` (Protobuf/gRPC), `capnp`, `rkyv`, `bincode`, `msgpack-rust`                                               | `aeson` (JSON), `yaml`, `binary`, `cereal`, `store` (compact binary), `proto-lens`/`grpc-haskell` (Protobuf/gRPC), `capnproto`, `flatbuffers`                                                               |
| **4. Concurrency & Parallelism**                  | Primitives and abstractions for concurrent/parallel execution: threads, async/await, actors, STM, work-stealing, GPU.                                        | `std::thread`, `tokio`, `async-std`, `futures`, `rayon`, `crossbeam`, `actix` (actors), `parking_lot` (better sync primitives)                                                     | `Control.Concurrent` (MVar, Chan, forkIO), `async`, `stm` (Software Transactional Memory), `parallel`, `accelerate` (GPU), `monad-par`                                                                      |
| **5. Networking & Distributed Communication**     | Low-level (TCP/UDP), high-level (HTTP/2, WebSockets), RPC frameworks, message queues (e.g., Kafka, RabbitMQ clients), P2P protocols.                         | `tokio::net`, `async-std::net`, `hyper` (HTTP), `reqwest` (HTTP client), `tonic` (gRPC), `zeromq`, `lapin`/`amiquip` (AMQP), `rdkafka`, `libp2p`                                   | `network`, `network-bsd`, `wai`/`warp` (HTTP server), `http-client`/`http-conduit` (HTTP client), `grpc-haskell`, `amqp`, `hw-kafka-client`, `zeromq-haskell`                                               |
| **6. Resilient Error Handling & Fault Tolerance** | Advanced error types, contextual errors, retry mechanisms, circuit breakers, bulkheads, structured error propagation.                                        | `anyhow`, `thiserror`, `eyre`, `snafu`, `retry`, `resilience` patterns (often custom or via general libraries)                                                                     | `mtl` (ExceptT), `errors`, `retry`, `Control.Exception` (extensible exceptions), custom applicative/monadic error handling, `unliftio` (resource handling)                                                  |
| **7. Observability (Logging, Metrics, Tracing)**  | Structured logging, metrics collection (Prometheus, StatsD), distributed tracing (OpenTelemetry, Jaeger, Zipkin), application performance monitoring (APM).  | `log` (facade), `tracing` (framework), `env_logger`, `slog`, `opentelemetry`, `prometheus`, `metrics` (facade)                                                                     | `monad-logger`, `katip`, `fast-logger`, `hslogger`, `ekg` (metrics), `opentelemetry` (emerging), `raven-haskell` (Sentry)                                                                                   |
| **8. Cryptography & Security Primitives**         | Hashing, encryption (symmetric/asymmetric), digital signatures, random number generation, key derivation, TLS/SSL.                                           | `ring`, `rustls`, `openssl` (bindings), `sodiumoxide`, `sha2`, `hmac`, `aes`, `rsa`, `dalek-cryptography` (ECC)                                                                    | `cryptonite`, `cryptohash-*`, `tls`, `HsOpenSSL`, `libsodium-bindings`, `saltine` (libsodium), `cryptography-padding`                                                                                       |
| **9. Database Systems & Storage**                 | SQL/NoSQL clients, ORMs, query builders, connection pooling, schema migrations, embedded databases.                                                          | `sqlx`, `diesel` (ORM), `rusqlite`, `postgres`, `mongodb`, `redis-rs`, `deadpool` (pooling), `refinery` (migrations)                                                               | `persistent`/`esqueleto` (ORM-like), `HDBC`, `postgresql-simple`/`postgresql-libpq`, `opaleye`, `acid-state` (embedded), `hedis` (Redis), `mongoDB`                                                         |
| **10. Optics & Advanced Data Manipulation**       | Lenses, Prisms, Traversals for principled, composable access and modification of complex immutable data structures.                                          | `lens-rs`, `optics` (emerging), often achieved with struct methods and functional patterns. Less central than in Haskell.                                                          | `lens` (very powerful, complex), `microlens` (simpler), `optics-core`/`optics` (modern alternatives)                                                                                                        |
| **11. Configuration Management**                  | Loading from files (JSON, YAML, TOML, env vars), validation, schema definition, dynamic reloading, feature flags.                                            | `config-rs`, `figment`, `serde` (for deserialization), `dotenv`                                                                                                                    | `configurator`, `dhall`, `yaml`, `aeson` (for deserialization), `dotenv-hs`                                                                                                                                 |
| **12. Operating System Interface & FFI**          | System calls, process management, filesystem manipulation (advanced), inter-process communication (IPC), platform-specific APIs, Foreign Function Interface. | `std::fs`, `std::process`, `libc`, `nix` (Unix APIs), `winapi` (Windows APIs), `shared_memory`, `interprocess`                                                                     | `System.Process`, `System.Directory`, `unix`, `Win32` (Windows APIs), `Foreign.*` modules (FFI)                                                                                                             |
| **13. Memory Management & Performance Profiling** | Custom allocators, memory analysis tools, GCs (understanding for Haskell), benchmarking, CPU/memory profilers.                                               | `std::alloc`, `jemallocator`, `mimalloc`, `cap`, `perf` (Linux tool), `flamegraph`, `valgrind` (via FFI if needed for C-libs)                                                      | GHC's runtime system (RTS) options for GC tuning, `ghc-prof` (profiler), `eventlog2html`, `criterion` (benchmarking), `weigh` (allocation profiling)                                                        |
| **14. Formal Methods & Program Verification**     | Libraries/tools for specifying and verifying program properties, theorem provers, model checkers (often external tools integrated with languages).           | `kani` (model checker), `Prusti` (verification via Viper), `Creusot` (verification). Interfacing with tools like TLA+, Coq, Isabelle.                                              | `LiquidHaskell` (refinement types), `Agda`, `Idris` (dependently typed languages), bindings or integrations with Coq, Isabelle/HOL.                                                                         |
| **15. Scientific & Numerical Computing**          | Linear algebra, numerical optimization, statistics, data frames, plotting, high-performance math.                                                            | `ndarray`, `nalgebra` (linear algebra), `statrs`, `polars` (data frames), `plotters`                                                                                               | `hmatrix`, `Numeric.LinearAlgebra.LAPACK`, `statistics`, `massiv` (arrays), `Chart` / `Chart-diagrams` (plotting), `repa` (parallel arrays)                                                                 |
| **16. Web Technologies & APIs**                   | Server frameworks, client libraries, WebAssembly (WASM) toolchains, GraphQL, templating engines.                                                             | `actix-web`, `axum`, `rocket`, `warp` (server), `reqwest` (client), `yew`/`leptos`/`dioxus` (WASM UI), `juniper` (GraphQL), `askama`/`tera` (templating)                           | `servant`, `yesod`, `scotty`, `spock` (server), `http-client` (client), `ghcjs`/GHC's WASM backend, `morpheus-graphql`, `shakespeare` (templating)                                                          |
| **17. Build Systems & Code Quality Tools**        | Advanced build automation, linters, formatters, dependency management beyond basics, code coverage.                                                          | `cargo` (built-in, extensive), `clippy` (linter), `rustfmt` (formatter), `tarpaulin` (coverage), `cross` (cross-compilation)                                                       | `cabal-install`/`stack` (build tools), `hlint` (linter), `ormolu`/`fourmolu`/`stylish-haskell` (formatters), `hpc` (coverage)                                                                               |
| **18. Identity, Authentication & Authorization**  | OAuth2/OIDC clients/servers, JWT handling, password hashing, permission systems, MACs.                                                                       | `oauth2`, `jsonwebtoken`, `biscuit-rust`, `argon2`, `bcrypt`, `ring` (for HMAC, etc.), `lettre` (email)                                                                            | `hoauth2`, `jwt`, `persistent- বলুন` (for user models), `cryptonite` (hashing, MACs), `wai-session`, `scotty-auth`, `mime-mail` (email)                                                                      |
| **19. Testing Frameworks (Advanced)**             | Property-based testing, BDD, integration testing harnesses, performance/load testing, mocking, mutation testing.                                             | `proptest`, `quickcheck`, `cucumber-rust` (BDD), `test-case`, `rstest`, `mockall`, `kani` (formal verification), `criterion` (benchmarking)                                        | `QuickCheck`, `hspec` (BDD), `tasty` (aggregator), `HUnit`, `doctest`, `hedgehog` (property testing), `mockery`, `criterion` (benchmarking)                                                                 |
| **20. Machine Learning & AI**                     | Framework bindings, tensor libraries, data processing pipelines, model deployment tools.                                                                     | `tch-rs` (PyTorch bindings), `rust-bert`, `linfa`, `candle` (ML framework by HuggingFace), `onnxruntime-rs`                                                                        | `grenade`, `hasktorch` (PyTorch bindings), `tensorflow-haskell`, various bindings to C/Python libraries via FFI, `pipes`/`conduit` for pipelines                                                            |
